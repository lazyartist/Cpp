#include <iostream>

using namespace std;

void _1802_literal () {
	cout << "===== 리터럴(literal)이란? =====" << endl;
	{
		/*
		리터럴은 변하지 않는 데이터 그 자체를 의미하고 실행파일에 바이너리로 포함된다.
		1, 1.1, "hello", 'c' 등이 리터럴이다.

		프로그램에서 사용된 리터럴 문자열은 전역적으로 접근이 가능하고 프로그램 종료까지 사라지지 않는다.
		따라서 함수에서 문자열 리터럴을 포인터를 반환해도 사라질 염려없이 계속 사용가능하다.
		물론 메모리 해제도 할 수 없고 런타임 에러난다.

		정수, 문자 리터럴도 바이너리로 포함되어 식에서 데이터로 사용되고 없어지지는 않지만 
		값을 복사할 원본 데이터 역할만 하고 포인터를 반환하지 않기 때문에 추후 접근은 불가능하다.

		프로그램 실행중 같은 리터럴 문자열의 주소가 같다.
		그럼 같은 리터럴 문자열은 실행파일에 한번만 포함되나?

		리터럴은 프로그램 영역이기 때문에 무조건 rvalue겠지만 rvalue과 성격이 같은지는 모르겠다.
		*/

		/*
		변수를 생성하고 리터럴 값을 복사
		*/
		int i = 1; // 변수 i를 생성하고 리터럴 1의 값을 복사
		i = 2; // i 값 변경 가능

		char ch = 'c'; // 변수 c를 생성하고 리터럴 'c'의 값을 복사
		ch = 'z'; // ch 값 변경 가능

		/*
		문자열 리터럴
		문자열 리터럴을 char[] 변수로 받으면 각 요소에 문자를 복사하여 변수가 생성된다.
		문자열 리터럴을 const char*로 받으면 리터럴 문자열의 포인터를 받는다.
		*/
		const char* str = nullptr; // const가 아니면 리터럴 문자열을 받을 수 없다.
		{
			str = "Hello"; // 리터럴 문자열의 포인터가 반환된다.
			char str2[] = "Hello"; // 리터럴 문자열을 배열에 복사한다.
		}
		cout << str << endl; // Hello, 블록을 벗어나도 리터럴 문자는 사라지지 않기 때문에 안심하고 사용할 수 있다.

		/*
		리터럴 문자열의 메모리를 해제할 경우 에러

		"HEAP CORRUPTION DETECTED: before Free block (#0) at 0x01275378.
		CRT detected that the application wrote to memory before start of heap buffer."
		
		"힙 손상 감지 : 0x01275378의 자유 블록 (# 0) 앞에. 
		CRT는 응용 프로그램이 힙 버퍼가 시작되기 전에 메모리에 쓴 것을 감지했습니다."
		*/
		//delete str;
	}
}