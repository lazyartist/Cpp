#include <iostream>
#include <functional> // C++11에서 함수포인터를 편하게 사용하기 위해 추가된 기능을 사용하기 위해 include

using namespace std;

/*
참고
	열혈 C++ 프로그래밍
	https://m.blog.naver.com/PostView.nhn?blogId=njuhb&logNo=140157805589&proxyReferer=https%3A%2F%2Fwww.google.com%2F

인라인 함수
	프로그램 코드라인 안으로 들어가 버린 함수
	함수의 몸체부분이 함수호출 문장을 완전히 대체했을 때 '함수가 인라인화 되었다'라고 한다.

	함수호출 문장을 완전히 대체하는 매크로 함수의 장점을 유지하고
	함수정의가 어려운 매크로 함수의 단점을 없앤것이 인라인 함수이다.

장점
	매크로보다 더 안전하고 쓰기 좋다.
	함수 호출 시 오버헤드가 없다.
	컴파일러의 최적화가 용이하다?

단점
	목적 코드의 크기가 커진다.
	중단점이 걸리지 않아 디버깅이 힘들다.
		코딩중에는 함수가 있지만 실행중에는 함수가 없기 때문

	매크로에 의한 인라인 함수는 전처리기에 의해 처리
	inline 키워드에 의한 인라인화는 컴파일러에 의해 처리.
		컴파일러는 함수의 인라인화가 해가 될 경우 무시한다.
		반대로 inline 키워드를 붙이지 않아도 알아서 인라인화 하는 경우도 있다.

명시적 인라인 요청
	함수 정의 앞에 inline 붙이기

암시적 인라인 대상
	클래스 선언 안에 함수를 바로 정의한 경우

인라인 제외 상황
	복잡한 함수
	루프가 있거나 재귀 함수
	가상함수
		가상함수는 함수를 런타임에 결정, 인라인은 컴파일에 결정하기 때문
	인라인 함수의 주소를 취하는 코드
		이 코드로 인해 아웃라인 함수 본문을 만들어야 하므로 인라인 되지 않는다.

선언 위치
	헤더파일에 선언
	컴파일러가 함수의 형태를 알아야 함수 호출을 본문으로 바꿀 수 있기 때문

사용 가이드라인
	작고, 자주 호출되는 함수에 대해서만 인라인 지정한다.

*/

namespace ns0704{
	// 인라인 함수의 정의 : 함수 앞에 inline 키워드를 추가한다
	inline void inf() {
		cout << "ns0704::inf()" << endl;
	}
}

void _0704_function_inline() {

	cout << "===== 인라인 함수 사용 =====" << endl;
	{
		ns0704::inf(); // 함수 호출문을 함수 몸체가 대체하여 컴파일된다.
	}
}